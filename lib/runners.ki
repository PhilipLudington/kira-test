// runners.ki: Test execution functions
//
// Pure and effect functions for running tests and suites.
// Includes timed execution and parallel runners.

module kira_test.runners

import kira_test.types.{AssertionResult, Passed, Failed, TestResult, TimedTestResult, TestCase, TestSuite, RunConfig, TestSummary, TimedTestSummary}
import kira_test.tagging.{filter_by_tags}

// =============================================================================
// Single Test Runners
// =============================================================================

/// Run a single test case and return the result.
fn run_test(tc: TestCase) -> TestResult {
    let result: AssertionResult = tc.run()
    match result {
        Passed => { return TestResult { name: tc.name, passed: true, message: "" } }
        Failed(msg) => { return TestResult { name: tc.name, passed: false, message: msg } }
    }
}

/// Run a single test case with optional before/after hooks.
fn run_test_with_hooks(tc: TestCase, before: Option[fn() -> void], after: Option[fn() -> void]) -> TestResult {
    match before {
        Some(before_fn) => { before_fn() }
        None => {}
    }

    let result: AssertionResult = tc.run()

    match after {
        Some(after_fn) => { after_fn() }
        None => {}
    }

    match result {
        Passed => { return TestResult { name: tc.name, passed: true, message: "" } }
        Failed(msg) => { return TestResult { name: tc.name, passed: false, message: msg } }
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn count_passed(acc: i32, r: TestResult) -> i32 {
    match r.passed {
        true => { return acc + 1 }
        false => { return acc }
    }
}

fn is_failed(r: TestResult) -> bool {
    match r.passed {
        true => { return false }
        false => { return true }
    }
}

// =============================================================================
// Suite Runners
// =============================================================================

/// Run all tests in a suite and return a summary.
fn run_suite(s: TestSuite) -> TestSummary {
    match s.setup {
        Some(setup_fn) => { setup_fn() }
        None => {}
    }

    let results: List[TestResult] = std.list.map(s.tests, fn(tc: TestCase) -> TestResult {
        return run_test_with_hooks(tc, s.before_each, s.after_each)
    })

    match s.teardown {
        Some(teardown_fn) => { teardown_fn() }
        None => {}
    }

    let total: i32 = std.list.length(results)
    let passed: i32 = std.list.fold(results, 0, count_passed)
    let failed: i32 = total - passed
    let failures: List[TestResult] = std.list.filter(results, is_failed)

    return TestSummary { suite_name: s.name, total: total, passed: passed, failed: failed, failures: failures }
}

/// Run tests with fail-fast support.
fn run_tests_fail_fast(tests: List[TestCase], before_each: Option[fn() -> void], after_each: Option[fn() -> void], fail_fast: bool) -> List[TestResult] {
    var results: List[TestResult] = Nil
    var should_continue: bool = true

    std.list.foreach(tests, fn(tc: TestCase) -> void {
        match should_continue {
            true => {
                let result: TestResult = run_test_with_hooks(tc, before_each, after_each)
                results = std.list.append(results, std.list.singleton(result))
                match fail_fast and not result.passed {
                    true => { should_continue = false }
                    false => {}
                }
            }
            false => {}
        }
        return
    })

    return results
}

/// Run a suite with configuration options.
fn run_suite_with_config(s: TestSuite, config: RunConfig) -> TestSummary {
    let filtered_tests: List[TestCase] = match config.tags_filter {
        Some(tags) => { return filter_by_tags(s.tests, tags) }
        None => { return s.tests }
    }

    match s.setup {
        Some(setup_fn) => { setup_fn() }
        None => {}
    }

    let results: List[TestResult] = run_tests_fail_fast(filtered_tests, s.before_each, s.after_each, config.fail_fast)

    match s.teardown {
        Some(teardown_fn) => { teardown_fn() }
        None => {}
    }

    let total: i32 = std.list.length(results)
    let passed: i32 = std.list.fold(results, 0, count_passed)
    let failed: i32 = total - passed
    let failures: List[TestResult] = std.list.filter(results, is_failed)

    return TestSummary { suite_name: s.name, total: total, passed: passed, failed: failed, failures: failures }
}

// =============================================================================
// Multiple Suite Runners
// =============================================================================

/// Run all suites and return summaries.
fn run_all_suites(suites: List[TestSuite]) -> List[TestSummary] {
    return std.list.map(suites, run_suite)
}

/// Run all suites with configuration, supporting fail-fast across suites.
fn run_all_suites_with_config(suites: List[TestSuite], config: RunConfig) -> List[TestSummary] {
    var summaries: List[TestSummary] = Nil
    var should_continue: bool = true

    std.list.foreach(suites, fn(s: TestSuite) -> void {
        match should_continue {
            true => {
                let summary: TestSummary = run_suite_with_config(s, config)
                summaries = std.list.append(summaries, std.list.singleton(summary))
                match config.fail_fast and summary.failed > 0 {
                    true => { should_continue = false }
                    false => {}
                }
            }
            false => {}
        }
        return
    })

    return summaries
}

// =============================================================================
// Timed Test Runners (Effect functions using std.time)
// =============================================================================

/// Helper for timed results
fn count_passed_timed(acc: i32, r: TimedTestResult) -> i32 {
    match r.passed {
        true => { return acc + 1 }
        false => { return acc }
    }
}

fn is_failed_timed(r: TimedTestResult) -> bool {
    match r.passed {
        true => { return false }
        false => { return true }
    }
}

fn sum_duration(acc: i64, r: TimedTestResult) -> i64 {
    return acc + r.duration_ms
}

/// Run a single test case with timing.
effect fn run_test_timed(tc: TestCase) -> IO[TimedTestResult] {
    let start: i64 = std.time.now_ms()
    let result: AssertionResult = tc.run()
    let end: i64 = std.time.now_ms()
    let duration: i64 = end - start

    match result {
        Passed => { return TimedTestResult { name: tc.name, passed: true, message: "", duration_ms: duration } }
        Failed(msg) => { return TimedTestResult { name: tc.name, passed: false, message: msg, duration_ms: duration } }
    }
}

/// Run a single test case with timing and hooks.
effect fn run_test_timed_with_hooks(tc: TestCase, before: Option[fn() -> void], after: Option[fn() -> void]) -> IO[TimedTestResult] {
    match before {
        Some(before_fn) => { before_fn() }
        None => {}
    }

    let start: i64 = std.time.now_ms()
    let result: AssertionResult = tc.run()
    let end: i64 = std.time.now_ms()
    let duration: i64 = end - start

    match after {
        Some(after_fn) => { after_fn() }
        None => {}
    }

    match result {
        Passed => { return TimedTestResult { name: tc.name, passed: true, message: "", duration_ms: duration } }
        Failed(msg) => { return TimedTestResult { name: tc.name, passed: false, message: msg, duration_ms: duration } }
    }
}

/// Run all tests in a suite with timing.
effect fn run_suite_timed(s: TestSuite) -> IO[TimedTestSummary] {
    match s.setup {
        Some(setup_fn) => { setup_fn() }
        None => {}
    }

    var results: List[TimedTestResult] = Nil
    std.list.foreach(s.tests, fn(tc: TestCase) -> void {
        let result: TimedTestResult = run_test_timed_with_hooks(tc, s.before_each, s.after_each)
        results = std.list.append(results, std.list.singleton(result))
        return
    })

    match s.teardown {
        Some(teardown_fn) => { teardown_fn() }
        None => {}
    }

    let total: i32 = std.list.length(results)
    let passed: i32 = std.list.fold(results, 0, count_passed_timed)
    let failed: i32 = total - passed
    let failures: List[TimedTestResult] = std.list.filter(results, is_failed_timed)
    let total_duration: i64 = std.list.fold(results, 0, sum_duration)

    return TimedTestSummary { suite_name: s.name, total: total, passed: passed, failed: failed, failures: failures, total_duration_ms: total_duration }
}

/// Run all suites with timing.
effect fn run_all_suites_timed(suites: List[TestSuite]) -> IO[List[TimedTestSummary]] {
    var summaries: List[TimedTestSummary] = Nil
    std.list.foreach(suites, fn(s: TestSuite) -> void {
        let summary: TimedTestSummary = run_suite_timed(s)
        summaries = std.list.append(summaries, std.list.singleton(summary))
        return
    })
    return summaries
}

// =============================================================================
// Parallel Test Runners (Effect functions using std.parallel)
// =============================================================================

/// Run a single test (for use with parallel map).
fn run_test_for_parallel(tc: TestCase) -> TestResult {
    return run_test(tc)
}

/// Run all tests in a suite in parallel.
/// Note: Hooks (before_each/after_each) are not supported in parallel mode
/// as they may have ordering dependencies or shared state.
effect fn run_suite_parallel(s: TestSuite) -> IO[TestSummary] {
    match s.setup {
        Some(setup_fn) => { setup_fn() }
        None => {}
    }

    // Run tests in parallel - hooks are skipped for thread safety
    let results: List[TestResult] = std.parallel.map(s.tests, run_test_for_parallel)

    match s.teardown {
        Some(teardown_fn) => { teardown_fn() }
        None => {}
    }

    let total: i32 = std.list.length(results)
    let passed: i32 = std.list.fold(results, 0, count_passed)
    let failed: i32 = total - passed
    let failures: List[TestResult] = std.list.filter(results, is_failed)

    return TestSummary { suite_name: s.name, total: total, passed: passed, failed: failed, failures: failures }
}

/// Run all suites in parallel.
effect fn run_all_suites_parallel(suites: List[TestSuite]) -> IO[List[TestSummary]] {
    return std.parallel.map(suites, run_suite_parallel)
}

/// Run a single test with timing (for use with parallel map).
effect fn run_test_timed_for_parallel(tc: TestCase) -> IO[TimedTestResult] {
    return run_test_timed(tc)
}

/// Run all tests in a suite in parallel with timing.
effect fn run_suite_parallel_timed(s: TestSuite) -> IO[TimedTestSummary] {
    let suite_start: i64 = std.time.now_ms()

    match s.setup {
        Some(setup_fn) => { setup_fn() }
        None => {}
    }

    // Run tests in parallel with timing
    let results: List[TimedTestResult] = std.parallel.map(s.tests, run_test_timed_for_parallel)

    match s.teardown {
        Some(teardown_fn) => { teardown_fn() }
        None => {}
    }

    let suite_end: i64 = std.time.now_ms()
    let total: i32 = std.list.length(results)
    let passed: i32 = std.list.fold(results, 0, count_passed_timed)
    let failed: i32 = total - passed
    let failures: List[TimedTestResult] = std.list.filter(results, is_failed_timed)
    // Use wall-clock time for parallel execution (not sum of individual times)
    let total_duration: i64 = suite_end - suite_start

    return TimedTestSummary { suite_name: s.name, total: total, passed: passed, failed: failed, failures: failures, total_duration_ms: total_duration }
}
