// test_demo.ki: Example usage of the kira-test framework
//
// Demonstrates testing various functions with different assertion types,
// including: tagging, hooks, fail-fast, range assertions, timing, and parallel execution.

module examples.test_demo

// Types
import kira_test.types.{AssertionResult, Passed, Failed, TestCase, TestSuite, RunConfig}

// Assertions
import kira_test.assertions.{
    assert_true, assert_false, assert_eq_i32, assert_eq_str, assert_eq_bool,
    assert_greater_i32, assert_less_i32,
    assert_some_i32, assert_none_i32, assert_some_eq_i32,
    assert_ok_i32, assert_err_i32, assert_ok_eq_i32,
    assert_err_contains_i32,
    assert_contains, assert_starts_with, assert_approx_eq,
    assert_in_range_i32, assert_in_range_f64
}

// Tagging
import kira_test.tagging.{has_tag, filter_by_tags}

// Builders
import kira_test.builders.{
    test, test_tagged, suite, suite_with_each, suite_full,
    default_config, config_fail_fast, config_with_tags, config_full
}

// Reporters
import kira_test.reporters.{
    run_and_report, run_and_report_with_config,
    run_and_report_timed, run_and_report_parallel, run_and_report_parallel_timed
}

// =============================================================================
// Functions to test
// =============================================================================

fn add(a: i32, b: i32) -> i32 {
    return a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    return a * b
}

fn is_positive(n: i32) -> bool {
    return n > 0
}

fn safe_divide(a: i32, b: i32) -> Result[i32, string] {
    match b == 0 {
        true => { return Err("Division by zero") }
        false => { return Ok(a / b) }
    }
}

fn find_first_positive(list: List[i32]) -> Option[i32] {
    return std.list.find(list, fn(n: i32) -> bool {
        return n > 0
    })
}

fn greet(name: string) -> string {
    return std.string.concat(std.string.concat("Hello, ", name), "!")
}

fn calculate_area(radius: f64) -> f64 {
    return 3.14159 * radius * radius
}

// =============================================================================
// Test Suites
// =============================================================================

fn math_tests() -> TestSuite {
    let t1: TestCase = test("add returns correct sum", fn() -> AssertionResult {
        return assert_eq_i32(5, add(2, 3))
    })

    let t2: TestCase = test("add handles negative numbers", fn() -> AssertionResult {
        return assert_eq_i32(-1, add(2, -3))
    })

    let t3: TestCase = test("multiply returns correct product", fn() -> AssertionResult {
        return assert_eq_i32(12, multiply(3, 4))
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.cons(t2, std.list.singleton(t3)))
    return suite("Math Tests", tests)
}

fn boolean_tests() -> TestSuite {
    let t1: TestCase = test("is_positive returns true for positive", fn() -> AssertionResult {
        return assert_true(is_positive(5))
    })

    let t2: TestCase = test("is_positive returns false for zero", fn() -> AssertionResult {
        return assert_false(is_positive(0))
    })

    let t3: TestCase = test("is_positive returns false for negative", fn() -> AssertionResult {
        return assert_false(is_positive(-3))
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.cons(t2, std.list.singleton(t3)))
    return suite("Boolean Tests", tests)
}

fn result_tests() -> TestSuite {
    let t1: TestCase = test("safe_divide returns Ok for valid division", fn() -> AssertionResult {
        return assert_ok_eq_i32(5, safe_divide(10, 2))
    })

    let t2: TestCase = test("safe_divide returns Err for division by zero", fn() -> AssertionResult {
        return assert_err_i32(safe_divide(10, 0))
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.singleton(t2))
    return suite("Result Tests", tests)
}

fn option_tests() -> TestSuite {
    let positive_list: List[i32] = std.list.cons(1, std.list.cons(2, std.list.singleton(3)))
    let negative_list: List[i32] = std.list.cons(-1, std.list.cons(-2, std.list.singleton(-3)))

    let t1: TestCase = test("find_first_positive returns Some when found", fn() -> AssertionResult {
        return assert_some_eq_i32(1, find_first_positive(positive_list))
    })

    let t2: TestCase = test("find_first_positive returns None when not found", fn() -> AssertionResult {
        return assert_none_i32(find_first_positive(negative_list))
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.singleton(t2))
    return suite("Option Tests", tests)
}

fn string_tests() -> TestSuite {
    let t1: TestCase = test("greet returns correct greeting", fn() -> AssertionResult {
        return assert_eq_str("Hello, World!", greet("World"))
    })

    let t2: TestCase = test("greeting starts with Hello", fn() -> AssertionResult {
        return assert_starts_with(greet("Alice"), "Hello")
    })

    let t3: TestCase = test("greeting contains name", fn() -> AssertionResult {
        return assert_contains(greet("Bob"), "Bob")
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.cons(t2, std.list.singleton(t3)))
    return suite("String Tests", tests)
}

fn float_tests() -> TestSuite {
    let t1: TestCase = test("calculate_area is approximately correct", fn() -> AssertionResult {
        return assert_approx_eq(78.54, calculate_area(5.0), 0.01)
    })

    let tests: List[TestCase] = std.list.singleton(t1)
    return suite("Float Tests", tests)
}

fn comparison_tests() -> TestSuite {
    let t1: TestCase = test("10 is greater than 5", fn() -> AssertionResult {
        return assert_greater_i32(5, 10)
    })

    let t2: TestCase = test("3 is less than 7", fn() -> AssertionResult {
        return assert_less_i32(7, 3)
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.singleton(t2))
    return suite("Comparison Tests", tests)
}

// =============================================================================
// New Feature Demos
// =============================================================================

// Demo: Range assertions
fn range_tests() -> TestSuite {
    let t1: TestCase = test("value is in range [0, 100]", fn() -> AssertionResult {
        return assert_in_range_i32(0, 100, 50)
    })

    let t2: TestCase = test("boundary value at min", fn() -> AssertionResult {
        return assert_in_range_i32(0, 100, 0)
    })

    let t3: TestCase = test("boundary value at max", fn() -> AssertionResult {
        return assert_in_range_i32(0, 100, 100)
    })

    let t4: TestCase = test("float in range [0.0, 1.0]", fn() -> AssertionResult {
        return assert_in_range_f64(0.0, 1.0, 0.5)
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.cons(t2, std.list.cons(t3, std.list.singleton(t4))))
    return suite("Range Tests", tests)
}

// Demo: Error message assertions
fn error_message_tests() -> TestSuite {
    let t1: TestCase = test("division by zero has correct message", fn() -> AssertionResult {
        return assert_err_contains_i32(safe_divide(10, 0), "zero")
    })

    let t2: TestCase = test("error message contains 'Division'", fn() -> AssertionResult {
        return assert_err_contains_i32(safe_divide(5, 0), "Division")
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.singleton(t2))
    return suite("Error Message Tests", tests)
}

// Demo: Tagged tests
fn tagged_tests() -> TestSuite {
    let unit_tag: List[string] = std.list.singleton("unit")
    let integration_tag: List[string] = std.list.singleton("integration")
    let slow_tag: List[string] = std.list.singleton("slow")

    let t1: TestCase = test_tagged("fast unit test 1", unit_tag, fn() -> AssertionResult {
        return assert_eq_i32(4, add(2, 2))
    })

    let t2: TestCase = test_tagged("fast unit test 2", unit_tag, fn() -> AssertionResult {
        return assert_true(is_positive(5))
    })

    let t3: TestCase = test_tagged("slow integration test", std.list.cons("integration", std.list.singleton("slow")), fn() -> AssertionResult {
        return assert_eq_str("Hello, Test!", greet("Test"))
    })

    let t4: TestCase = test_tagged("another integration test", integration_tag, fn() -> AssertionResult {
        return assert_ok_i32(safe_divide(10, 2))
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.cons(t2, std.list.cons(t3, std.list.singleton(t4))))
    return suite("Tagged Tests", tests)
}

// Demo: Before/after each hooks (simplified - no global mutable state)
fn hook_tests() -> TestSuite {
    // Note: Hook demonstration simplified because module-level mutable variables
    // are not supported. Hooks are passed to suite_with_each but state tracking
    // would require a different approach.
    let t1: TestCase = test("hook test (first)", fn() -> AssertionResult {
        return assert_true(true)
    })

    let t2: TestCase = test("hook test (second)", fn() -> AssertionResult {
        return assert_true(true)
    })

    let t3: TestCase = test("hook test (third)", fn() -> AssertionResult {
        return assert_true(true)
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.cons(t2, std.list.singleton(t3)))
    let noop: fn() -> void = fn() -> void { return }
    return suite_with_each("Hook Tests", tests, noop, noop)
}

// Demo: Fail-fast behavior
fn fail_fast_demo_tests() -> TestSuite {
    let t1: TestCase = test("passes first", fn() -> AssertionResult {
        return assert_true(true)
    })

    let t2: TestCase = test("fails second (stops here with fail-fast)", fn() -> AssertionResult {
        return assert_true(false)
    })

    let t3: TestCase = test("would pass third (skipped with fail-fast)", fn() -> AssertionResult {
        return assert_true(true)
    })

    let tests: List[TestCase] = std.list.cons(t1, std.list.cons(t2, std.list.singleton(t3)))
    return suite("Fail-Fast Demo", tests)
}

// =============================================================================
// Main Entry Point
// =============================================================================

effect fn main() -> void {
    print("=== Running Standard Tests ===")
    print("")

    let s1: TestSuite = math_tests()
    let s2: TestSuite = boolean_tests()
    let s3: TestSuite = result_tests()
    let s4: TestSuite = option_tests()
    let s5: TestSuite = string_tests()
    let s6: TestSuite = float_tests()
    let s7: TestSuite = comparison_tests()

    let standard_suites: List[TestSuite] = std.list.cons(s1, std.list.cons(s2, std.list.cons(s3, std.list.cons(s4, std.list.cons(s5, std.list.cons(s6, std.list.singleton(s7)))))))

    let standard_passed: bool = run_and_report(standard_suites)

    print("")
    print("=== Running New Feature Tests ===")
    print("")

    // New feature test suites
    let s8: TestSuite = range_tests()
    let s9: TestSuite = error_message_tests()
    let s10: TestSuite = hook_tests()

    let new_feature_suites: List[TestSuite] = std.list.cons(s8, std.list.cons(s9, std.list.singleton(s10)))

    let new_features_passed: bool = run_and_report(new_feature_suites)

    print("")
    print("=== Demo: Tagged Tests (running only 'unit' tagged tests) ===")
    print("")

    let s11: TestSuite = tagged_tests()
    let tagged_suites: List[TestSuite] = std.list.singleton(s11)
    let unit_tags: List[string] = std.list.singleton("unit")
    let tag_config: RunConfig = config_with_tags(unit_tags)

    let tagged_passed: bool = run_and_report_with_config(tagged_suites, tag_config)

    print("")
    print("=== Demo: Fail-Fast Mode (stops on first failure) ===")
    print("")

    let s12: TestSuite = fail_fast_demo_tests()
    let fail_fast_suites: List[TestSuite] = std.list.singleton(s12)
    let ff_config: RunConfig = config_fail_fast()

    let ff_passed: bool = run_and_report_with_config(fail_fast_suites, ff_config)

    print("")
    print("=== Demo: Timed Test Execution ===")
    print("")

    // Run with timing - shows duration for each suite
    let timed_suites: List[TestSuite] = std.list.cons(math_tests(), std.list.cons(boolean_tests(), std.list.singleton(result_tests())))
    let timed_passed: bool = run_and_report_timed(timed_suites)

    print("")
    print("=== Demo: Parallel Test Execution ===")
    print("")

    // Run tests in parallel - faster for independent tests
    let parallel_suites: List[TestSuite] = std.list.cons(string_tests(), std.list.cons(float_tests(), std.list.singleton(comparison_tests())))
    let parallel_passed: bool = run_and_report_parallel(parallel_suites)

    print("")
    print("=== Demo: Parallel + Timed Execution ===")
    print("")

    // Run tests in parallel with timing - best of both worlds
    let parallel_timed_suites: List[TestSuite] = std.list.cons(math_tests(), std.list.cons(range_tests(), std.list.singleton(error_message_tests())))
    let parallel_timed_passed: bool = run_and_report_parallel_timed(parallel_timed_suites)

    print("")
    print("=== Summary ===")
    print("")

    match standard_passed and new_features_passed and timed_passed and parallel_passed and parallel_timed_passed {
        true => { print("All main test suites passed!") }
        false => { print("Some tests failed.") }
    }

    print("(Note: Fail-fast demo intentionally has a failing test)")
}
