//! Internal tests using direct imports (no kira_test. prefix)
//! This allows running tests from within the kira_test package.

module tests.internal_tests

import types.{AssertionResult, Passed, Failed, TestCase, TestSuite, TestSummary}
import assertions.{
    // Boolean
    assert_true,
    assert_false,
    // Equality
    assert_eq_i32,
    assert_not_eq_i32,
    assert_eq_i64,
    assert_not_eq_i64,
    assert_eq_str,
    assert_not_eq_str,
    assert_eq_bool,
    assert_eq_f64,
    assert_approx_eq,
    // Comparison i32
    assert_greater_i32,
    assert_less_i32,
    assert_greater_or_eq_i32,
    assert_less_or_eq_i32,
    // Comparison i64
    assert_greater_i64,
    assert_less_i64,
    assert_greater_or_eq_i64,
    assert_less_or_eq_i64,
    // Comparison f64
    assert_greater_f64,
    assert_less_f64,
    assert_greater_or_eq_f64,
    assert_less_or_eq_f64,
    // Range
    assert_in_range_i32,
    assert_in_range_i64,
    assert_in_range_f64,
    // Option
    assert_some_i32,
    assert_none_i32,
    assert_some_eq_i32,
    assert_some_str,
    assert_none_str,
    assert_some_eq_str,
    assert_some_f64,
    assert_none_f64,
    assert_some_eq_f64,
    // Result
    assert_ok_i32,
    assert_err_i32,
    assert_ok_eq_i32,
    assert_ok_str,
    assert_ok_eq_str,
    assert_err_str,
    // String content
    assert_contains,
    assert_starts_with,
    assert_ends_with,
    assert_not_contains,
    assert_not_starts_with,
    assert_not_ends_with,
    // String value
    assert_empty_string,
    assert_not_empty_string,
    assert_str_length,
    // List i32
    assert_empty_i32,
    assert_not_empty_i32,
    assert_length_i32,
    assert_contains_i32,
    assert_not_contains_i32,
    assert_eq_list_i32,
    // List string
    assert_empty_str_list,
    assert_not_empty_str_list,
    assert_length_str_list,
    assert_contains_str_list,
    assert_eq_list_str,
    // Predicates
    assert_all_i32,
    assert_any_i32,
    assert_all_str,
    assert_any_str,
    // One-of
    assert_one_of_i32,
    assert_one_of_str,
    // Custom
    assert_satisfies_i32,
    assert_satisfies_str
}
import builders.{test, suite}
import runners.{run_suite}

// =============================================================================
// Helper predicates
// =============================================================================

let is_positive: fn(i32) -> bool = fn(x: i32) -> bool {
    return x > 0
}

let is_even: fn(i32) -> bool = fn(x: i32) -> bool {
    return x % 2 == 0
}

let is_non_empty: fn(string) -> bool = fn(s: string) -> bool {
    return std.string.length(s) > 0
}

// =============================================================================
// Boolean Tests
// =============================================================================

let boolean_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_true passes", fn() -> AssertionResult { return assert_true(true) }),
        Cons(
            test("assert_false passes", fn() -> AssertionResult { return assert_false(false) }),
            Nil
        )
    )
}

// =============================================================================
// Equality Tests
// =============================================================================

let equality_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_eq_i32 passes", fn() -> AssertionResult { return assert_eq_i32(42, 42) }),
        Cons(
            test("assert_not_eq_i32 passes", fn() -> AssertionResult { return assert_not_eq_i32(1, 2) }),
            Cons(
                test("assert_eq_i64 passes", fn() -> AssertionResult { return assert_eq_i64(100, 100) }),
                Cons(
                    test("assert_eq_str passes", fn() -> AssertionResult { return assert_eq_str("hello", "hello") }),
                    Cons(
                        test("assert_eq_bool passes", fn() -> AssertionResult { return assert_eq_bool(true, true) }),
                        Cons(
                            test("assert_eq_f64 passes", fn() -> AssertionResult { return assert_eq_f64(3.14, 3.14) }),
                            Cons(
                                test("assert_approx_eq passes", fn() -> AssertionResult { return assert_approx_eq(3.14, 3.141, 0.01) }),
                                Nil
                            )
                        )
                    )
                )
            )
        )
    )
}

// =============================================================================
// Comparison Tests
// =============================================================================

let comparison_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_greater_i32 passes", fn() -> AssertionResult { return assert_greater_i32(5, 10) }),
        Cons(
            test("assert_less_i32 passes", fn() -> AssertionResult { return assert_less_i32(10, 5) }),
            Cons(
                test("assert_greater_or_eq_i32 passes", fn() -> AssertionResult { return assert_greater_or_eq_i32(5, 5) }),
                Cons(
                    test("assert_less_or_eq_i32 passes", fn() -> AssertionResult { return assert_less_or_eq_i32(5, 5) }),
                    Cons(
                        test("assert_greater_i64 passes", fn() -> AssertionResult { return assert_greater_i64(50, 100) }),
                        Cons(
                            test("assert_greater_f64 passes", fn() -> AssertionResult { return assert_greater_f64(1.0, 2.0) }),
                            Cons(
                                test("assert_in_range_i32 passes", fn() -> AssertionResult { return assert_in_range_i32(0, 10, 5) }),
                                Cons(
                                    test("assert_in_range_i64 passes", fn() -> AssertionResult { return assert_in_range_i64(0, 100, 50) }),
                                    Nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
}

// =============================================================================
// Option Tests
// =============================================================================

let option_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_some_i32 passes", fn() -> AssertionResult { return assert_some_i32(Some(42)) }),
        Cons(
            test("assert_none_i32 passes", fn() -> AssertionResult { return assert_none_i32(None) }),
            Cons(
                test("assert_some_eq_i32 passes", fn() -> AssertionResult { return assert_some_eq_i32(42, Some(42)) }),
                Cons(
                    test("assert_some_str passes", fn() -> AssertionResult { return assert_some_str(Some("hello")) }),
                    Cons(
                        test("assert_none_str passes", fn() -> AssertionResult { return assert_none_str(None) }),
                        Cons(
                            test("assert_some_f64 passes", fn() -> AssertionResult { return assert_some_f64(Some(3.14)) }),
                            Cons(
                                test("assert_none_f64 passes", fn() -> AssertionResult { return assert_none_f64(None) }),
                                Nil
                            )
                        )
                    )
                )
            )
        )
    )
}

// =============================================================================
// Result Tests
// =============================================================================

let result_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_ok_i32 passes", fn() -> AssertionResult { return assert_ok_i32(Ok(42)) }),
        Cons(
            test("assert_err_i32 passes", fn() -> AssertionResult { return assert_err_i32(Err("error")) }),
            Cons(
                test("assert_ok_eq_i32 passes", fn() -> AssertionResult { return assert_ok_eq_i32(42, Ok(42)) }),
                Cons(
                    test("assert_ok_str passes", fn() -> AssertionResult { return assert_ok_str(Ok("success")) }),
                    Cons(
                        test("assert_ok_eq_str passes", fn() -> AssertionResult { return assert_ok_eq_str("hello", Ok("hello")) }),
                        Nil
                    )
                )
            )
        )
    )
}

// =============================================================================
// String Tests
// =============================================================================

let string_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_contains passes", fn() -> AssertionResult { return assert_contains("hello world", "world") }),
        Cons(
            test("assert_starts_with passes", fn() -> AssertionResult { return assert_starts_with("hello", "hel") }),
            Cons(
                test("assert_ends_with passes", fn() -> AssertionResult { return assert_ends_with("hello", "llo") }),
                Cons(
                    test("assert_not_contains passes", fn() -> AssertionResult { return assert_not_contains("hello", "xyz") }),
                    Cons(
                        test("assert_not_starts_with passes", fn() -> AssertionResult { return assert_not_starts_with("hello", "xyz") }),
                        Cons(
                            test("assert_not_ends_with passes", fn() -> AssertionResult { return assert_not_ends_with("hello", "xyz") }),
                            Cons(
                                test("assert_empty_string passes", fn() -> AssertionResult { return assert_empty_string("") }),
                                Cons(
                                    test("assert_not_empty_string passes", fn() -> AssertionResult { return assert_not_empty_string("hi") }),
                                    Cons(
                                        test("assert_str_length passes", fn() -> AssertionResult { return assert_str_length(5, "hello") }),
                                        Nil
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
}

// =============================================================================
// List Tests
// =============================================================================

let list_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_empty_i32 passes", fn() -> AssertionResult { return assert_empty_i32(Nil) }),
        Cons(
            test("assert_not_empty_i32 passes", fn() -> AssertionResult { return assert_not_empty_i32(Cons(1, Nil)) }),
            Cons(
                test("assert_length_i32 passes", fn() -> AssertionResult { return assert_length_i32(3, Cons(1, Cons(2, Cons(3, Nil)))) }),
                Cons(
                    test("assert_contains_i32 passes", fn() -> AssertionResult { return assert_contains_i32(Cons(1, Cons(2, Nil)), 2) }),
                    Cons(
                        test("assert_not_contains_i32 passes", fn() -> AssertionResult { return assert_not_contains_i32(Cons(1, Cons(2, Nil)), 5) }),
                        Cons(
                            test("assert_eq_list_i32 passes", fn() -> AssertionResult { return assert_eq_list_i32(Cons(1, Cons(2, Nil)), Cons(1, Cons(2, Nil))) }),
                            Cons(
                                test("assert_empty_str_list passes", fn() -> AssertionResult { return assert_empty_str_list(Nil) }),
                                Cons(
                                    test("assert_contains_str_list passes", fn() -> AssertionResult { return assert_contains_str_list(Cons("a", Cons("b", Nil)), "b") }),
                                    Nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
}

// =============================================================================
// Predicate Tests
// =============================================================================

let predicate_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    return Cons(
        test("assert_all_i32 passes", fn() -> AssertionResult { return assert_all_i32(Cons(2, Cons(4, Cons(6, Nil))), is_even) }),
        Cons(
            test("assert_any_i32 passes", fn() -> AssertionResult { return assert_any_i32(Cons(1, Cons(2, Cons(3, Nil))), is_even) }),
            Cons(
                test("assert_all_str passes", fn() -> AssertionResult { return assert_all_str(Cons("a", Cons("bc", Nil)), is_non_empty) }),
                Cons(
                    test("assert_one_of_i32 passes", fn() -> AssertionResult { return assert_one_of_i32(2, Cons(1, Cons(2, Cons(3, Nil)))) }),
                    Cons(
                        test("assert_one_of_str passes", fn() -> AssertionResult { return assert_one_of_str("b", Cons("a", Cons("b", Cons("c", Nil)))) }),
                        Cons(
                            test("assert_satisfies_i32 passes", fn() -> AssertionResult { return assert_satisfies_i32(5, is_positive, "be positive") }),
                            Nil
                        )
                    )
                )
            )
        )
    )
}

// =============================================================================
// Concatenate all test lists
// =============================================================================

let concat_lists: fn(List[TestCase], List[TestCase]) -> List[TestCase] = fn(a: List[TestCase], b: List[TestCase]) -> List[TestCase] {
    match a {
        Nil => { return b }
        Cons(head, tail) => { return Cons(head, concat_lists(tail, b)) }
    }
}

let all_tests: fn() -> List[TestCase] = fn() -> List[TestCase] {
    let t1: List[TestCase] = boolean_tests()
    let t2: List[TestCase] = equality_tests()
    let t3: List[TestCase] = comparison_tests()
    let t4: List[TestCase] = option_tests()
    let t5: List[TestCase] = result_tests()
    let t6: List[TestCase] = string_tests()
    let t7: List[TestCase] = list_tests()
    let t8: List[TestCase] = predicate_tests()

    let combined: List[TestCase] = concat_lists(t1,
        concat_lists(t2,
            concat_lists(t3,
                concat_lists(t4,
                    concat_lists(t5,
                        concat_lists(t6,
                            concat_lists(t7, t8)))))))
    return combined
}

// =============================================================================
// Main
// =============================================================================

effect fn main() -> IO[void] {
    std.io.println("=== kira-test Internal Test Suite ===")
    std.io.println("")

    let s: TestSuite = suite("All Assertions", all_tests())
    let summary: TestSummary = run_suite(s)

    std.io.println("")
    std.io.println(std.string.concat(std.string.from_i32(summary.passed), " passed"))
    std.io.println(std.string.concat(std.string.from_i32(summary.failed), " failed"))

    return
}
